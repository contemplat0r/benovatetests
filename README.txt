1. Напишите класс, который хранит список своих экземпляров и позволяет итерировать по ним.
    >>> a = Keeper()
    >>> b = Keeper()
    >>> for i in Keeper.list_instances():
    ...    print i
    <Keeper instance at 0x…>

Реализация класса Keeper находится в файле keeper.py



2. В чем отличие (i for i in arr) от [i for i in arr]? Напишите генератор следующего вида
gen = reverse_gen([1, 2, 3, 4])
>>> gen.next()
4
>>> gen.next()
3
>>> gen.next()
2
>>> gen.next()
1
>>> gen.next()
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
StopIteration
    Ответ:
В первом случае мы получаем генератор,  во втором случае получаем list посредством list comprehension.

Реализация генератора reverse_gen находится в файле reverse_gen.py



3. Есть следующая функция:
def myappend(a = [], num = 0):
    a.append(num)
    print a
Что будет происходить при выполнении следующего кода и почему:
    >>> a = [1,2,3]
    >>> myappend(a)
    >>> myappend()
    >>> myappend()
    
Значение по умолчанию вычисляется для функции один раз во время определения функции, в дальнейших вызовах функции без параметра, используется ссылка на вычисленную при определении переменную. В данном случае переменная - изменяемый объект (список), значение которого меняется в теле функции. Соответственно при каждом вызове функции myappend со значениями  параметров по умолчанию, к списку a который во время определения функции получил значение [], добавляется 0.



4. Что такое декораторы? Для чего они нужны? Напишите кеширующий декоратор, который можно применить к функции get_long_response и который, если результат уже есть в кеше CACHE, вернет его, а если нет, то закеширует результат выполнения функции в CACHE и вернет его (результат). Результат выполнения функции get_long_response уникален для ее параметра user_id.

class Cache(object):
   __cache = {}
   __slots__ = '__cache',

   @classmethod
   def get(cls, key):
       print 'get', key
       return cls.__cache[key]

   @classmethod
   def set(cls, key, value):
       print 'set', key, value
       cls.__cache[key] = value

   @classmethod
   def has(cls, key):
       print 'has', key
       return key in cls.__cache

CACHE = Cache()

def cache_decorator(func):
...


def get_long_response(user_id):
   return user_id * 1000

print get_long_response(12)
print
print get_long_response(15)
print
print get_long_response(12)
print

    Ответ.
Фактически декоратор — это синтаксический сахар для следующей конструкции f = decorator(f), где f — некая функция (хотя существуют и декораторы методов и декораторы классов). Декоратор, в свою очередь — это  callable объект, т. е. функция либо экземпляр класса для которого определён метод __call__.   Декораторы используются для изменения поведения по умолчанию функции (или callable объекта) к которому применяются. Например cache_decorator используется для того, что бы не вычислять повторно уже вычисленное. Декоратор @staticmethod используется для того, что бы сделать метод класса статическим. require_POST декоратор в Django модифицирует поведение view таким образом что view может принимать только POST запросы. Так же декораторы могут не менять поведение декорируемой функции , а например, регистрировать её в какой-нибудь глобальной таблице.

Реализация cache_decorator находится в файле cache_decorator.py


6. (Опционально) На входе - артикул (формат: последовательности цифр и букв разделены точкой или пробелом). необходимо заменить точки на пробелы и пробелы на точки с учетом всех возможных комбинаций. 
Например, на входе артикул (разделители только точки)
1.2.3
1.2
1.2.3.4.5.6
На выходе должно быть:
1.2.3
1 2.3
1.2 3
1 2 3

Решение - в файле articuls.py
